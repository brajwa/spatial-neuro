theme(legend.position="top", legend.text=element_text(size=8), legend.title = element_blank(),
legend.key.height = unit(0.3, 'cm'), legend.key.width = unit(0.3, 'cm'),
legend.box.margin=margin(-10,-10,-10,-10),
plot.title = element_text(hjust = 0.5, size=10),
plot.subtitle = element_text(hjust = 0.5, size=8),
axis.text.x = element_text(size = 7.5), axis.text.y = element_text(size = 7.5),
axis.title.x = element_text(size = 8), axis.title.y = element_text(size = 8),
panel.background = element_rect(fill='white', colour='black'),
panel.grid.major = element_line(color = "grey", linewidth=0.2, linetype=2)) +
custom_colors + custom_colors_2 +
xlab(expression(paste("Edge Length"))) + ylab("Density")  )  # the titles needs changing for different runs
dev.off()
# edge angle
den_org_e_angle = density(apply(branch.all, 1, function(x) calcAngle(x)))
den_org_e_angle = data.frame(x=den_org_e_angle$x, y=den_org_e_angle$y)
den_sim_e_angle = density(network_extra1$anglecomp)
den_sim_e_angle = data.frame(x=den_sim_e_angle$x, y= den_sim_e_angle$y)
svglite(paste("D:/Fall 2023/Research/Prelim/figures/init tri figures/init_tri_edge_angle.svg", sep=""), width = 1.85, height = 1.35)
print(ggplot() +
geom_line(data = den_org_e_angle, aes(x=x, y=y, color = "real"), size=0.1) +
geom_area(data = den_org_e_angle, aes(x=x, y=y, fill = "real"), alpha=0.3)+
geom_line(data = den_sim_e_angle, aes(x=x, y=y, color="triangulated"), size=0.1) +
geom_area(data = den_sim_e_angle, aes(x=x, y=y, fill="triangulated"), alpha=0.3) +
theme(legend.position="top", legend.text=element_text(size=8), legend.title = element_blank(),
legend.key.height = unit(0.3, 'cm'), legend.key.width = unit(0.3, 'cm'),
legend.box.margin=margin(-10,-10,-10,-10),
plot.title = element_text(hjust = 0.5, size=10),
plot.subtitle = element_text(hjust = 0.5, size=8),
axis.text.x = element_text(size = 7.5), axis.text.y = element_text(size = 7.5),
axis.title.x = element_text(size = 8), axis.title.y = element_text(size = 8),
panel.background = element_rect(fill='white', colour='black'),
panel.grid.major = element_line(color = "grey", linewidth=0.2, linetype=2)) +
custom_colors + custom_colors_2 +
xlab(expression(paste("Edge Angle"))) + ylab("Density") ) # the titles needs changing for different runs
dev.off()
}
comparePlotOrgSim2 <- function(org_face_feature, face_features, branch.all, network_extra1){
cat("Number of faces in the original network: ", length(org_face_feature$X))
cat("\nNumber of faces in the simulated network: ", length(face_features$area), "\n")
myColors = c("blue", "green")
names(myColors) = c("real", "simulated")
custom_colors = scale_colour_manual(name = "Network type", values = myColors)
custom_colors_2 = scale_fill_manual(name = "Network type", values = myColors)
# node count
den_org_nc = density(org_face_feature$Node_Count)
den_org_nc = data.frame(x=den_org_nc$x, y=den_org_nc$y)
den_sim_nc = density(face_features$Node_Count)
den_sim_nc = data.frame(x=den_sim_nc$x, y=den_sim_nc$y)
svglite(paste("D:/Fall 2023/Research/Presentations/Research Progress Figures/",
"simulated_node_count.svg", sep=""), width = 8, height = 6)
print(ggplot() +
geom_line(data = den_org_nc, aes(x=x, y=y, color = "real")) +
geom_area(data = den_org_nc, aes(x=x, y=y, fill = "real"), alpha=0.3) +
geom_line(data = den_sim_nc, aes(x=x, y=y, color="simulated")) +
geom_area(data = den_sim_nc, aes(x=x, y=y, fill="simulated"), alpha=0.3) +
theme(legend.position="top", legend.text=element_text(size=16), legend.title = element_blank(),
legend.box.margin=margin(-10,-10,-10,-10),
plot.title = element_text(hjust = 0.5, size=18),
plot.subtitle = element_text(hjust = 0.5, size=16),
axis.text.x = element_text(size = 16), axis.text.y = element_text(size = 16),
axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16),
panel.background = element_rect(fill='white', colour='black'),
panel.grid.major = element_line(color = "grey", linewidth=0.25, linetype=2)) +
custom_colors + custom_colors_2 +
xlab(expression(paste("Face Node Count"))) + ylab("Density")+
labs(title = "Comparison of face feature of original and simulated network")  )# the titles needs changing for different runs
dev.off()
# area
den_org_area = density(org_face_feature$Area_SL)
den_org_area = data.frame(x=den_org_area$x, y=den_org_area$y)
den_sim_area = density(face_features$area)
den_sim_area = data.frame(x=den_sim_area$x, y=den_sim_area$y)
svglite(paste("D:/Fall 2023/Research/Presentations/Research Progress Figures/",
"simulated_face_area.svg", sep=""), width = 8, height = 6)
print(ggplot() +
geom_line(data = den_org_area, aes(x=x, y=y, color = "real")) +
geom_area(data = den_org_area, aes(x=x, y=y, fill = "real"), alpha=0.3) +
geom_line(data = den_sim_area, aes(x=x, y=y, color="simulated")) +
geom_area(data = den_sim_area, aes(x=x, y=y, fill="simulated"), alpha=0.3) +
theme(legend.position="top", legend.text=element_text(size=16), legend.title = element_blank(),
legend.box.margin=margin(-10,-10,-10,-10),
plot.title = element_text(hjust = 0.5, size=18),
plot.subtitle = element_text(hjust = 0.5, size=16),
axis.text.x = element_text(size = 16), axis.text.y = element_text(size = 16),
axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16),
panel.background = element_rect(fill='white', colour='black'),
panel.grid.major = element_line(color = "grey", linewidth=0.25, linetype=2)) +
custom_colors + custom_colors_2 +
xlab(expression(paste("Face Area"))) + ylab("Density")+
labs(title = "Comparison of face feature of original and simulated network") )  # the titles needs changing for different runs
dev.off()
# elongation
den_org_elong = density(org_face_feature$Elong.)
den_org_elong = data.frame(x=den_org_elong$x, y=den_org_elong$y)
den_sim_elong = density(face_features$elong)
den_sim_elong = data.frame(x=den_sim_elong$x, y= den_sim_elong$y)
svglite(paste("D:/Fall 2023/Research/Presentations/Research Progress Figures/",
"simulated_face_elong.svg", sep=""), width = 8, height = 6)
print(ggplot() +
geom_line(data = den_org_elong, aes(x=x, y=y, color = "real")) +
geom_area(data = den_org_elong, aes(x=x, y=y, fill = "real"), alpha=0.3) +
geom_line(data = den_sim_elong, aes(x=x, y=y, color="simulated")) +
geom_area(data = den_sim_elong, aes(x=x, y=y, fill="simulated"), alpha=0.3) +
theme(legend.position="top", legend.text=element_text(size=16), legend.title = element_blank(),
legend.box.margin=margin(-10,-10,-10,-10),
plot.title = element_text(hjust = 0.5, size=18),
plot.subtitle = element_text(hjust = 0.5, size=16),
axis.text.x = element_text(size = 16), axis.text.y = element_text(size = 16),
axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16),
panel.background = element_rect(fill='white', colour='black'),
panel.grid.major = element_line(color = "grey", linewidth=0.25, linetype=2)) +
custom_colors + custom_colors_2 +
xlab(expression(paste("Face Elongation"))) + ylab("Density")+
labs(title = "Comparison of face feature of original and simulated network")  )  # the titles needs changing for different runs
dev.off()
# orientation
den_org_orient = density(org_face_feature$Orient.)
den_org_orient = data.frame(x=den_org_orient$x, y=den_org_orient$y)
den_sim_orient = density(face_features$orient)
den_sim_orient = data.frame(x=den_sim_orient$x, y= den_sim_orient$y)
svglite(paste("D:/Fall 2023/Research/Presentations/Research Progress Figures/",
"simulated_face_orient.svg", sep=""), width = 8, height = 6)
print(ggplot() +
geom_line(data = den_org_orient, aes(x=x, y=y, color = "real")) +
geom_area(data = den_org_orient, aes(x=x, y=y, fill = "real"), alpha=0.3) +
geom_line(data = den_sim_orient, aes(x=x, y=y, color="simulated")) +
geom_area(data = den_sim_orient, aes(x=x, y=y, fill="simulated"), alpha=0.3) +
theme(legend.position="top", legend.text=element_text(size=16), legend.title = element_blank(),
legend.box.margin=margin(-10,-10,-10,-10),
plot.title = element_text(hjust = 0.5, size=18),
plot.subtitle = element_text(hjust = 0.5, size=16),
axis.text.x = element_text(size = 16), axis.text.y = element_text(size = 16),
axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16),
panel.background = element_rect(fill='white', colour='black'),
panel.grid.major = element_line(color = "grey", linewidth=0.25, linetype=2)) +
custom_colors + custom_colors_2 +
xlab(expression(paste("Face Orientation"))) + ylab("Density")+
labs(title = "Comparison of face feature of original and simulated network")  )  # the titles needs changing for different runs
dev.off()
# edge length
den_org_e_len = density(branch.all$euclid)
den_org_e_len = data.frame(x=den_org_e_len$x, y=den_org_e_len$y)
den_sim_e_len = density(network_extra1$euclidDist)
den_sim_e_len = data.frame(x=den_sim_e_len$x, y= den_sim_e_len$y)
svglite(paste("D:/Fall 2023/Research/Presentations/Research Progress Figures/",
"simulated_edge_len.svg", sep=""), width = 8, height = 6)
print(ggplot() +
geom_line(data = den_org_e_len, aes(x=x, y=y, color = "real")) +
geom_area(data = den_org_e_len, aes(x=x, y=y, fill = "real"), alpha=0.3) +
geom_line(data = den_sim_e_len, aes(x=x, y=y, color="simulated")) +
geom_area(data = den_sim_e_len, aes(x=x, y=y, fill="simulated"), alpha=0.3) +
theme(legend.position="top", legend.text=element_text(size=16), legend.title = element_blank(),
legend.box.margin=margin(-10,-10,-10,-10),
plot.title = element_text(hjust = 0.5, size=18),
plot.subtitle = element_text(hjust = 0.5, size=16),
axis.text.x = element_text(size = 16), axis.text.y = element_text(size = 16),
axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16),
panel.background = element_rect(fill='white', colour='black'),
panel.grid.major = element_line(color = "grey", linewidth=0.25, linetype=2)) +
custom_colors + custom_colors_2 +
xlab(expression(paste("Edge Length"))) + ylab("Density")+
labs(title = "Comparison of edge feature of original and simulated network")  )  # the titles needs changing for different runs
dev.off()
# edge angle
den_org_e_angle = density(apply(branch.all, 1, function(x) calcAngle(x)))
den_org_e_angle = data.frame(x=den_org_e_angle$x, y=den_org_e_angle$y)
den_sim_e_angle = density(network_extra1$anglecomp)
den_sim_e_angle = data.frame(x=den_sim_e_angle$x, y= den_sim_e_angle$y)
svglite(paste("D:/Fall 2023/Research/Presentations/Research Progress Figures/",
"simulated_edge_angle.svg", sep=""), width = 8, height = 6)
print(ggplot() +
geom_line(data = den_org_e_angle, aes(x=x, y=y, color = "real")) +
geom_area(data = den_org_e_angle, aes(x=x, y=y, fill = "real"), alpha=0.3)+
geom_line(data = den_sim_e_angle, aes(x=x, y=y, color="simulated")) +
geom_area(data = den_sim_e_angle, aes(x=x, y=y, fill="simulated"), alpha=0.3) +
theme(legend.position="top", legend.text=element_text(size=16), legend.title = element_blank(),
legend.box.margin=margin(-10,-10,-10,-10),
plot.title = element_text(hjust = 0.5, size=18),
plot.subtitle = element_text(hjust = 0.5, size=16),
axis.text.x = element_text(size = 16), axis.text.y = element_text(size = 16),
axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16),
panel.background = element_rect(fill='white', colour='black'),
panel.grid.major = element_line(color = "grey", linewidth=0.25, linetype=2)) +
custom_colors + custom_colors_2 +
xlab(expression(paste("Edge Angle"))) + ylab("Density")+
labs(title = "Comparison of edge feature of original and simulated network") ) # the titles needs changing for different runs
dev.off()
}
########################################################################
#### computes an edge weight based on the degree of its two end vertices
#### g2_degree is the list of degree of each vertex in the graph under consideration
#### x is the edge whose weight is being computed, the 5th and 6th index provides the indices of the end vertices
computeEdgeWeight <- function(g2_degree, x){
return(g2_degree[x[5]] + g2_degree[x[6]])
}
####Given the degree of vertices of the current network and the max degree of the original network,
#### compute the probability of each vertex
computeVertexProb <- function(org_max_deg, g2_degree, network_extra1){
y = c(min(g2_degree):max(g2_degree))
deg_prob = mySoftMax(y)
v_prob = c()
for (d in g2_degree) {
v_prob = c(v_prob, deg_prob$get(as.character(d)))
}
return(v_prob)
}
computeVertexProb2 <- function(org_max_deg, g2_degree, network_extra1){
g2_degree_n = c()
for (i in c(1:length(g2_degree))) {
adj_vertices_from_df = c(network_extra1$ind1[network_extra1$ind2==i],
network_extra1$ind2[network_extra1$ind1==i])
g2_degree_n = c(g2_degree_n, g2_degree[i] + sum(g2_degree[adj_vertices_from_df]) )
}
y = c(min(g2_degree_n):max(g2_degree_n))
deg_prob = mySoftMax(y)
v_prob = c()
for (d in g2_degree_n) {
v_prob = c(v_prob, deg_prob$get(as.character(d)))
}
return(v_prob)
}
#### Given a face and an edge find if that edge is present in the face
isEdgeOnFace <- function(face, edge){
face = as.numeric(face)
matched_index = which(face %in% edge)
if(length(matched_index) < 2){
return(FALSE)
}else{
if((abs(matched_index[1] - matched_index[2]) == 1) | (abs(matched_index[1] - matched_index[2]) == (length(face)-1))){
return(TRUE)
}else{
return(FALSE)
}
}
}
####Given a point pattern object, this function computes the boundary edges
####to get closed boundary faces
####the additional edges this function computes only depend on the point pattern
####as it only connects the corner points of the point pattern window and
####the boundary points of the point pattern sequentially
computeBoundaryEdges <- function(branch.ppp){
pp_nodes = data.frame(x=branch.ppp$x, y=branch.ppp$y)
####include the window corner nodes to the point pattern
pp_nodes = rbind(pp_nodes, data.frame(x=c(branch.ppp$window$xrange[1], branch.ppp$window$xrange[2], branch.ppp$window$xrange[2], branch.ppp$window$xrange[1]),
y=c(branch.ppp$window$yrange[2], branch.ppp$window$yrange[2], branch.ppp$window$yrange[1], branch.ppp$window$yrange[1])))
#### nodes at the left side of the network, ordered from bottom to top
boundary_1 = pp_nodes[pp_nodes$x <= branch.ppp$window$xrange[1], ]
boundary_1 = boundary_1[order(boundary_1$y), ]
boundary_1 = as.integer(rownames(boundary_1))   # vertex ids
#### nodes at the top, ordered from left to right
boundary_2 = pp_nodes[pp_nodes$y >= branch.ppp$window$yrange[2], ]
boundary_2 = boundary_2[order(boundary_2$x), ]
boundary_2 = as.integer(rownames(boundary_2))
#### nodes at the right side, ordered from top to bottom
boundary_3 = pp_nodes[pp_nodes$x >= branch.ppp$window$xrange[2], ]
boundary_3 = boundary_3[order(boundary_3$y, decreasing = TRUE), ]
boundary_3 = as.integer(rownames(boundary_3))
#### nodes at the bottom, ordered from right to left
boundary_4 = pp_nodes[pp_nodes$y <= branch.ppp$window$yrange[1], ]
boundary_4 = boundary_4[order(boundary_4$x, decreasing = TRUE), ]
boundary_4 = as.integer(rownames(boundary_4))
#### the new edges will connect the boundary nodes computed above sequentially and
####create a loop by connecting the last node to the first one.
#### to avoid shifting error
if(length(boundary_1) == 1){
b_1 = c()
}else{
b_1 = boundary_1[2:length(boundary_1)]
}
new_edges = data.frame(ind1 = c(boundary_1, boundary_2, boundary_3, boundary_4),
ind2 = c(b_1, boundary_2, boundary_3, boundary_4, boundary_1[1]))
new_edges = new_edges[new_edges$ind1 != new_edges$ind2, ]  # removing self loops at the corner nodes
return(new_edges)
}
#### given a face (as sequence of vertex ids) and the network edges
#### this function returns the edge ids that are on the face
compuateFaceEdges <- function(face, network_extra, gen.ppp){
n = length(face)
edges = c()
for (i in c(1:(n-1))) {
for (j in c((i+1):n)) {
v1 = as.numeric(face[i])
v2 = as.numeric(face[j])
lines(c(gen.ppp$x[v1], gen.ppp$x[v2]), c(gen.ppp$y[v1], gen.ppp$y[v2]), col="blue", lwd=3)
edges = c(edges, which((network_extra$ind1 == v1 & network_extra$ind2 == v2) |
(network_extra$ind1 == v2 & network_extra$ind2 == v1)) )
}
}
return(edges)
}
#### Given the pont pattern and the data structure of the network, computes the clustering coefficient by constructing
#### the corresponding graph object
ccFromDataframe <- function(branch.ppp, network_extra){
graph_obj =  make_empty_graph() %>% add_vertices(branch.ppp$n)
graph_obj = add_edges(as.undirected(graph_obj),
as.vector(t(as.matrix(network_extra[,5:6]))))
#### Transitivity measures the probability that the adjacent vertices of a vertex are connected.
#### This is sometimes also called the clustering coefficient.
cluster_coeff = igraph::transitivity(graph_obj, type = "global")
return(cluster_coeff)
}
####Given the pont pattern and the data structure of the network, computes the other network metrics
netMetrics <- function(gen.ppp, network_extra){
#### alpha, gamma, psi (meshedness, network density and compactness parameters)
N = gen.ppp$n
E = length(network_extra$x1)
A = summary(gen.ppp)$window$area
L = sum(network_extra$euclidDist)
meshedness = (E-N+1)/((2*N)-5)
network_density = E/((3*N)-6)
compactness = 1- ((4*A)/(L-(2*sqrt(A)))^2)
cat("Meshedness: ", meshedness, ", Network density: ", network_density, ", Compactness: ", compactness, "\n")
return(list(meshedness, network_density, compactness))
}
#### given a single or list of edge index and the current network structure,
#### eliminated the given edges from the network and
#### recomputes all network features
eliminateEdges <- function(gen.ppp, network_extra1, edges_to_eliminate){
temp_network_extra1 = network_extra1[-c(edges_to_eliminate), ]
temp_graph_obj = make_empty_graph() %>% add_vertices(gen.ppp$n)
temp_graph_obj = add_edges(as.undirected(temp_graph_obj),
as.vector(t(as.matrix(temp_network_extra1[,5:6]))))
temp_g_o <- as_graphnel(temp_graph_obj)
boyerMyrvoldPlanarityTest(temp_g_o)
temp_face_list = planarFaceTraversal(temp_g_o)
temp_face_node_count = sapply(temp_face_list, length)
#### applying the shoe lace formula
temp_face_area_list = sapply(temp_face_list, function(x) faceArea(x, gen.ppp))
#### eliminating the outer face, it has the largest face area
temp_face_node_count = temp_face_node_count[-which.max(temp_face_area_list)]
temp_face_list = temp_face_list[-which.max(temp_face_area_list)]
temp_face_area_list = temp_face_area_list[-which.max(temp_face_area_list)]
#### face features computation
temp_columns = c("Area_CF", "Perim.", "Ext.", "Disp.", "Elong.", "Eccentr.", "Orient.") # Area_CF: from contour function
temp_face_features = data.frame(matrix(nrow = 0, ncol = length(temp_columns)))
colnames(temp_face_features) = temp_columns
temp_face_convexity_list = c()
for(f in c(1: length(temp_face_list))){
temp_f_feat = computeFacefeatures(f, temp_face_list, gen.ppp, NULL)
temp_face_features = rbind(temp_face_features, temp_f_feat)
temp_face_convexity_list = c(temp_face_convexity_list, computeFaceConvexity(temp_face_list[[f]], gen.ppp))
}# loop ends for each face of the network
temp_face_features$Node_Count = temp_face_node_count
temp_triKDE_face_feat_1 = kde(as.matrix(data.frame(temp_face_area_list, temp_face_features$orient)))
temp_triKDE_face_feat_2 = kde(as.matrix(data.frame((temp_face_node_count))),
h=density((temp_face_node_count))$bw)
temp_triKDE_edge_feat = kde(as.matrix(data.frame((network_extra1$anglecomp),
(network_extra1$euclidDist))))
#### remove the edges, there is a change
cat("Edge(s) deleted\n")
noChange = 0
#### make necessary changes permanent
network_extra1 = temp_network_extra1
g2_degree = igraph::degree(temp_graph_obj, mode="total")
print(table(g2_degree))
face_list = temp_face_list
face_area_list = temp_face_area_list
face_node_count = temp_face_node_count
triKDE_face_feat_1 = temp_triKDE_face_feat_1
triKDE_face_feat_2 = temp_triKDE_face_feat_2
triKDE_edge_feat = temp_triKDE_edge_feat
tri_face_features = temp_face_features
tri_face_convexity_mean = mean(temp_face_convexity_list)
if(!is_connected(temp_graph_obj)){
cat("NETWORK GOT DISCONNECTED\n")
}
return(list(noChange, network_extra1, g2_degree, face_list, face_area_list, face_node_count,
triKDE_face_feat_1, triKDE_face_feat_2, triKDE_edge_feat, tri_face_features, tri_face_convexity_mean))
}
#### given a list of tentative edges to reject, and the edge feature estimations of the
#### original and the current networks, selects an edge to reject
selectEdge <- function(tent_edges, network_extra1, orgKDE_edge_feat, triKDE_edge_feat){
set.seed(Sys.time())
tent_edges = sample(tent_edges) #shuffle
for (te in tent_edges) {
org_edge_est = predict(orgKDE_edge_feat, x=c((network_extra1$anglecomp)[te], (network_extra1$euclidDist)[te]))
tri_edge_est = predict(triKDE_edge_feat, x=c((network_extra1$anglecomp)[te], (network_extra1$euclidDist)[te]))
if(tri_edge_est  > org_edge_est){
return(te)
}
}
#### if none of them satisfies the criterion, return a random one of them
cat("Random edge selected\n")
set.seed(Sys.time())
return(sample(tent_edges, 1))
}
#### given a list of tentative edges to reject, and the edge feature estimations of the
#### original and the current networks, selects many edge to reject
selectMultEdges <- function(tent_edges, network_extra1, orgKDE_edge_feat, triKDE_edge_feat){
set.seed(Sys.time())
tent_edges = sample(tent_edges) #shuffle
e_list = c()
for (te in tent_edges) {
org_edge_est = predict(orgKDE_edge_feat, x=c((network_extra1$anglecomp)[te], (network_extra1$euclidDist)[te]))
tri_edge_est = predict(triKDE_edge_feat, x=c((network_extra1$anglecomp)[te], (network_extra1$euclidDist)[te]))
if(tri_edge_est  > org_edge_est){
e_list = c(e_list, te)
}
}
if(length(e_list) == 0){
#### if none of them satisfies the criterion, return a random one of them
cat("Random edge selected\n")
return(tent_edges)
}else{
return(e_list)
}
}
selectMultEdges2 <- function(tent_edges, network_extra1, orgKDE_edge_feat, triKDE_edge_feat){
set.seed(Sys.time())
return(sample(tent_edges)) #shuffle and return
}
#### detects if a vertex is a corner of the pp boundary
isCornerV <- function(v, gen.ppp){
#cat("!!!!!!!!!!!!!!!!!!!!!!!!Inside isCornerV 1!!!!!!!!!!!!!!!!!!!!!!!!!!\n")
v_x = gen.ppp$x[v]
v_y = gen.ppp$y[v]
cond1 = (v_x %in% gen.ppp$window$xrange)
cond2 = (v_y %in% gen.ppp$window$yrange)
#cat("!!!!!!!!!!!!!!!!!!!!!!!!Inside isCornerV 2!!!!!!!!!!!!!!!!!!!!!!!!!!\n")
if(is.na(cond1) | is.na(cond2)){
return(FALSE)
}else{
if(cond1 & cond2){
return(TRUE)
}else{
return(FALSE)
}
}
}
deterministicEdges_3 <- function(gen.ppp, branch.ppp, branch.all, org_face_feature, sample_id, org_face_convexity_mean, org_face_convexity_sd){
#### construct the Delaunay triangulation on the parent points as a starter network
#### ord_point_list: to maintain the order of the points
ord_point_list = data.frame(x = gen.ppp$x, y = gen.ppp$y)
network_triangulation = deldir(ord_point_list[, 1:2])
#### construct a convenient data structure to keep the triangulation information
network_extra1 = data.frame(x1=network_triangulation$delsgs$x1, y1=network_triangulation$delsgs$y1,
x2=network_triangulation$delsgs$x2, y2=network_triangulation$delsgs$y2,
ind1=network_triangulation$delsgs$ind1, ind2=network_triangulation$delsgs$ind2)
network_extra1$euclidDist = apply(network_extra1, 1, function(x) sqrt( ((x[1]-x[3])^2) + ((x[2]-x[4])^2) ) )
network_extra1$anglecomp = apply(network_extra1, 1, function(x) calcAngle(x))
###################################################################################
#### distance of each vertex from the point pattern boundary
vertex_dist_boundary = bdist.points(gen.ppp)
####index of the boundary edges
bb_edges = which((vertex_dist_boundary[network_extra1$ind1]==0) &
(vertex_dist_boundary[network_extra1$ind2]==0) &
((gen.ppp$x[network_extra1$ind1]==gen.ppp$x[network_extra1$ind2])|
(gen.ppp$y[network_extra1$ind1]==gen.ppp$y[network_extra1$ind2]) ) )
#### eliminate the edges from the triangulation whose length is larger/smaller than the max/min edge length
#### in the original network
#### then recompute the face features and KDE required
org_max_edge_length = max(branch.all$euclid)
org_min_edge_length = min(branch.all$euclid)
edges_to_eliminate = c(which(network_extra1$euclidDist > org_max_edge_length),
which(network_extra1$euclidDist < org_min_edge_length))
#### but we do not eliminate any boundary edge [for now]
edges_to_eliminate = setdiff(edges_to_eliminate, bb_edges)
cat("Eliminating larger and smaller edges\n")
after_elim = eliminateEdges(gen.ppp, network_extra1, edges_to_eliminate)
noChange = after_elim[[1]]
network_extra1 = after_elim[[2]]
g2_degree = after_elim[[3]]
face_list = after_elim[[4]]
face_area_list = after_elim[[5]]
face_node_count = after_elim[[6]]
triKDE_face_feat_1 = after_elim[[7]]
triKDE_face_feat_2 = after_elim[[8]]
triKDE_edge_feat = after_elim[[9]]
face_features = after_elim[[10]]
face_convexity_mean = after_elim[[11]]
cat("tri avg face convexity:", face_convexity_mean, "\n")
###################################################################################
#### new
#### Reminder: The initial triangulation already has closed faces at  the boundary,
#### no need to add extra edges before computing the faces.
#### compute the face feature of the triangulation
graph_obj =  graph_from_data_frame(unique(network_extra1[, 5:6]), directed = FALSE)
#### Transitivity measures the probability that the adjacent vertices of a vertex are connected.
#### This is sometimes also called the clustering coefficient.
cluster_coeff_t = igraph::transitivity(graph_obj, type = "global")
cat("CC DT: ", cluster_coeff_t, "\n")
#### create another copy of the data structure
network_extra = rbind(network_extra1)
#### construct and display as corresponding ppp and linnet
degs = (igraph::degree(graph_obj, mode="total"))
ord = order(as.numeric(names(degs)))
degs = degs[ord]
#### attach the degree information to the point pattern for proper visualization
marks(gen.ppp) = factor(degs)
gen.ppp$markformat = "factor"
g_o_lin = linnet(gen.ppp, edges=as.matrix(network_extra[,5:6]))
branch.lpp_dt = lpp(gen.ppp, g_o_lin )
####new
####plot the feature densities of the initial triangulation vs the original network for comparison
comparePlotOrgSim(org_face_feature, face_features, branch.all, network_extra)
####new end
plot(branch.lpp_dt, main="Initial DT", pch=21, cex=1.2, bg=c("black", "red3", "green3", "orange",
"dodgerblue", "white", "maroon1",
"mediumpurple", "yellow", "cyan"))
svglite(paste("D:/Fall 2023/Research/Prelim/figures/init tri figures/init_dt.svg", sep=""), width = 2.5, height = 1.8)
plot(branch.lpp_dt, main="", pch=21, cex=1.2, bg=c("black", "red3", "green3", "orange",
"dodgerblue", "white", "maroon1",
"mediumpurple", "yellow", "cyan"))
dev.off()
#### degree list of the constructed Delaunay graph again for edge weight calculation
g_o_degree = degs
network_extra$weight = apply(network_extra, 1, function(x) computeEdgeWeight(g_o_degree, x))
network_extra$weight = range01(network_extra$weight)
return(list(network_extra, face_list, face_area_list, face_node_count, triKDE_face_feat_1, triKDE_face_feat_2, triKDE_edge_feat, g_o_degree, face_features))
}
install.packages("ggplot2")
install.packages("ggplot2")
